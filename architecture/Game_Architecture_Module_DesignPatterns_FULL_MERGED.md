
# 게임 개발 관점 **아키텍처 · 모듈 · 디자인 패턴** 통합본 (게임 & 비게임 예시 포함)

> 모든 목록에 대해 **정의 / 장단점 / 게임 예시 / 비게임 예시** 포함  
> 이전 파일들의 내용을 전부 합쳐 다시 생성

---

## 1) 아키텍처 패턴

| 패턴 | 정의 | 장점 | 단점 | 게임 예시 | 비게임 예시 |
|---|---|---|---|---|---|
| Layered (N‑Tier) | UI·도메인·데이터 접근을 계층 분리 | 관심사 분리, 테스트 용이 | 계층 경유 성능 저하, 횡단 관심사 전파 | RPG에서 UI ↔ 전투 규칙 ↔ 세이브 | 전자상거래 웹앱(프론트↔비즈↔DB) |
| Client‑Server(권위) | 서버가 판정·동기화 담당 | 공정성, 치트 방지 | 레이턴시 보정 복잡, 서버 비용 | FPS/MOBA/MMO | 은행 온라인 거래(클라이언트-서버) |
| Microservices | 기능별 서비스 독립 배포·확장 | 팀별 독립성, 장애 격리 | 분산 복잡성, 관측 난이도 | 매치·랭킹·결제 서비스 분리 | 넷플릭스·아마존 백엔드 |
| Event‑Driven | 이벤트 발행/구독 기반 느슨 결합 | 확장성·스파이크 흡수 | 최종 일관성, 디버깅 어려움 | 보스 처치 → 업적·보상·알림 | 주문 결제 → 배송·메일·포인트 |
| Hexagonal / Clean | 도메인 로직 중심, 외부 의존은 포트·어댑터로 격리 | 테스트·교체 용이 | 초기 추상화 비용 | 전투 규칙은 고정, 렌더러/DB 교체 자유 | 회계·ERP 시스템(교체/테스트 편리) |
| Pipe‑and‑Filter | 데이터를 단계적 필터로 변환·파이프 연결 | 테스트·재사용·병렬화 쉬움 | 포맷/복사 비용, 병목 위험 | 애셋 빌드(모델→LOD→압축) | 영상 처리(FFmpeg 필터 체인) |
| Microkernel | 최소 코어 + 플러그인 확장 | 기능 추가 쉬움, 생태계 구축 | 플러그인 호환/보안/버전 관리 | 게임 에디터의 임포터·검증기 플러그인 | VSCode 확장 구조 |
| ECS | 엔티티(ID)+컴포넌트(데이터)+시스템(로직) | 캐시 효율, 대량 객체 처리 | 학습 곡선, 디버깅 어려움 | 유닛·투사체·파티클 업데이트 | 로보틱스 시뮬레이터(수많은 센서) |
| MVC / MVP / MVVM | UI·로직·모델 분리 | 테스트/협업 용이 | 바인딩 복잡, 성능 고려 | 인벤토리·HUD UI | 회계 프로그램 GUI |
| CQRS / Event Sourcing | 읽기/쓰기 모델 분리, 변경 이력 이벤트로 저장 | 읽기 스케일·리플레이·감사 용이 | 이벤트 스키마 진화·일관성 설계 복잡 | 랭킹 조회 vs 매치 기록 분리 | 대형 커머스 주문 조회 vs 결제 처리 |
| Master‑Worker | 작업을 워커에 분산 | 탄력 확장, 병렬 처리 | 의존성·재시도·실패 처리 필요 | 라이트맵 베이킹·애셋 변환 | 빅데이터 집계·MapReduce |
| P2P / Lockstep | 클라이언트 간 입력 동기화로 결정적 시뮬레이션 | 서버 비용 절감 | 치트 취약·지연 민감 | 고전 RTS | 파일 공유 네트워크(BitTorrent) |
| Blackboard | 공용 지식 저장소에 다수 전문가 에이전트가 접근 | 복합 문제 해결 | 경합/우선순위/수렴 설계 필요 | 보스 AI(전술·스킬·거리 계산 협업) | 의료 진단 지원 시스템 |
| Actor Model | Actor가 메시지 기반 비동기 통신 | 동시성·격리·복원력 | 메시지 폭주·순서 보장 필요 | MMO의 존·채팅·알림 액터 | 채팅/메시징 서버(Erlang 기반) |

---

## 2) 모듈 (Module)

### 2.1 정의
- 시스템을 **기능/책임별로 구획한 독립 코드 단위**
- 외부에는 **계약(API)**만 공개, 내부 구현은 캡슐화
- 팀 단위 개발·테스트·배포 단위를 제공

### 2.2 게임 예시
- **Gameplay/Rules**: 전투 규칙, 점수 시스템
- **Renderer**: 드로우, 셰이더, 파이프라인
- **Physics**: 충돌 감지, 물리 시뮬
- **Animation**: 상태 머신, 블렌딩
- **AI**: 행동 트리, 경로 탐색
- **Networking**: 상태 동기화, 스냅샷, 예측
- **UI/HUD**: 위젯, 데이터 바인딩
- **Persistence**: 세이브·로드, 직렬화
- **Resource/Asset Manager**: 로딩, 캐싱, 메모리 관리
- **Telemetry/Analytics**: 게임 이벤트, 통계
- **Tools/Editor**: 에디터, 임포터, 스크립트

### 2.3 비게임 예시
- **User Management 모듈**: 인증·인가
- **Payment 모듈**: 결제 처리·정산
- **Logging 모듈**: 로그 수집·집계
- **Reporting 모듈**: 데이터 리포트 생성
- **Notification 모듈**: 알림 발송

### 2.4 모듈 장점 / 단점
| 장점 | 단점 |
|---|---|
| 팀 병렬 개발, 유지보수·테스트·배포 용이 | 경계·API 설계가 미흡하면 결합도↑ |
| 관심사 분리 → 코드 품질 향상 | 크로스 모듈 데이터 이동 비용·복잡성 |
| 성능 병목을 특정 모듈로 격리 가능 | 공통 모듈(God Manager)로 집중 → 오히려 스파게티 |
| 교체·확장 시 영향 최소화 | 초기 설계 비용·문서 필요 |

### 2.5 설계 핵심
- **단일 책임** / **명확한 API와 전제조건**
- **데이터 소유권/수명** (Factory·RAII·Handle)
- **동기 vs 비동기** 경로 명확화
- **스레딩 모델**: 잡 시스템·메시지 큐
- **테스트 포인트 확보**: 골든 리플레이, 시드 고정
- **관측 가능성**: 로깅·트레이스·카운터

---

## 3) 디자인 패턴 (GoF 23 + 현대 확장)

| 분류 | 패턴 | 정의 | 장점 | 단점 | 게임 예시 | 비게임 예시 |
|---|---|---|---|---|---|---|
| 생성 | Abstract Factory | 연관 객체군 생성 인터페이스 | 교체·일관성 | 클래스 증가 | 플랫폼별 GUI·입력 팩 | 결제 서비스별 API 클라이언트 생성 |
| 〃 | Factory Method | 서브클래스가 생성 책임 | 유연성↑ | 상속 남용 | Weapon이 투사체 생성 | 문서 파서 팩토리 |
| 〃 | Builder | 단계적 조립·불변객체 | 가독성↑, 테스트↑ | 보일러플레이트 | 캐릭터·로드아웃 생성 | PDF 리포트 빌더 |
| 〃 | Prototype | 복제로 생성 | 생성 비용 절감 | 깊은/얕은 복제 이슈 | 투사체·파티클 클론 | 이미지 썸네일 복제 |
| 〃 | Singleton | 전역 1개 보장 | 접근 단순 | 테스트·결합 문제 | InputManager / AudioMixer | 앱 설정 ConfigManager |
| 구조 | Adapter | 인터페이스 변환 | 레거시 통합 | 변환 오버헤드 | 콘솔 컨트롤러 API 어댑터 | 구형 결제 API → 공통 인터페이스 |
| 〃 | Bridge | 추상/구현 독립 확장 | 교체 자유 | 초기 설계량↑ | IRenderer ↔ DX/Vulkan | DB 추상 ↔ MySQL/Oracle |
| 〃 | Composite | 트리 부분/전체 동일 인터페이스 | 재귀 처리 쉬움 | 순환·업데이트 순서 | 씬 노드, UI 위젯 트리 | 폴더/파일 탐색기 |
| 〃 | Decorator | 런타임 기능 덧입힘 | 조합성↑ | 디버깅 어려움 | 무기 속성(독/화염) 추가 | GUI 컴포넌트 스크롤바·테두리 |
| 〃 | Facade | 복잡 서브시스템에 단일 진입점 | 사용 단순화 | 응집↑ → God Object 위험 | Audio.playMusic() | DB 연결 + 캐시 + 로깅 추상화 |
| 〃 | Flyweight | 공유로 메모리 절약 | 외재 상태 관리 필요 | 파티클·탄환·트리 인스턴스 | 글꼴 글리프 공유 |
| 〃 | Proxy | 대리로 지연/원격/보안 | 캐시·지연 관리 | 네트워크 엔티티 프록시 | 원격 파일 서비스 프록시 |
| 행위 | Chain of Responsibility | 처리 연쇄로 핸들러 탐색 | 우선권 유연 | 누락/디버깅 어려움 | 입력 이벤트 체인(UI→게임→카메라) | 웹서버 미들웨어 체인 |
| 〃 | Command | 요청을 객체화(Undo/Redo) | Undo/리플레이·큐잉 | 로그·충돌 관리 | 에디터 편집 기록·리플레이 | 텍스트 편집기 Undo/Redo |
| 〃 | Interpreter | DSL 구문 해석 | 유연성↑ | 성능/보안↓ | 퀘스트 스크립트, 콘솔 명령 | 수식 계산기 |
| 〃 | Iterator | 컬렉션 순회 표준화 | 구현 단순·호환 | 무효화 주의 | ECS 뷰 이터레이터 | DB 레코드 순회 |
| 〃 | Mediator | 객체 상호작용 중재자 집중 | 결합도↓ | 중재자 비대화 위험 | 인벤토리↔상점 UI | 채팅창 탭·알림 중재 |
| 〃 | Memento | 내부 상태 스냅샷 저장/복구 | 롤백·체크포인트 | 메모리↑·보안 주의 | 퍼즐 상태 롤백, 체크포인트 | 워드프로세서 버전 히스토리 |
| 〃 | Observer | 발행/구독 알림 | 느슨 결합 | 구독 해제 누락/폭주 | HP 변동→HUD 업데이트 | 주식 시세 알림 |
| 〃 | State | 상태별 행동 캡슐화 | 분기 제거 | 상태 폭발 위험 | NPC 상태(Idle/Chase/Attack) | 워크플로 단계별 행동 |
| 〃 | Strategy | 알고리즘 교체 가능 | 유연성↑ | 전략 난립 | AI 행동 알고리즘 교체 | 결제 수수료 계산 전략 |
| 〃 | Template Method | 알고리즘 골격+훅 | 공통 골격 확보 | 상속 남용 | 씬 로딩 순서 훅 | 데이터 처리 파이프라인 단계 훅 |
| 〃 | Visitor | 구조 고정·새 연산 쉽게 추가 | 새 타입 추가 비용 | 씬 노드 충돌 경계 계산 | AST 기반 코드 분석 |

---

## 4) 선택 가이드 및 체크리스트

- 먼저 **품질 속성(성능/확장/운영)** 우선순위를 합의 → 아키텍처 결정
- 팀 조직·기능 단위로 **모듈 경계** 정의 → API·데이터 흐름 문서화
- 모듈 내부의 반복 문제에 **디자인 패턴** 적용(과용 금지)
- 테스트·관측 가능성·버전 호환·보안 고려

**체크리스트**
- [ ] 아키텍처 다이어그램(컴포넌트/상호작용/데이터 흐름) 작성
- [ ] 모듈 경계와 데이터 소유권·스레딩 모델 명확화
- [ ] ECS/DOD 등 데이터 핫패스 최적화
- [ ] 반복 문제에 적합한 디자인 패턴 선정
- [ ] 로깅·트레이스·프로파일·에러 보고 체계 구축

---

## 5) 결론
- **아키텍처**: 시스템 큰 그림 (도시 지도)  
- **모듈**: 조직 단위/기능 경계 (구역·건물)  
- **디자인 패턴**: 모듈 내부의 검증된 설계 기법 (건물 내부 설계)

> **모듈 경계가 선명할수록** 아키텍처가 깔끔해지고,  
> **디자인 패턴은 그 안에서 빛난다.**
