# Dragonic Tactics - 구현 계획

**목적**: architecture.md의 전체 시스템 설계를 기반으로 한 유연한 우선순위 기반 개발 계획

**전략**: 5명의 개발자가 현재 팀 목표에 따라 우선순위를 조정하며 개발

**최종 업데이트**: 2025-11-27

**중요**: 이 문서는 architecture.md의 모든 시스템을 포함하되, 향후 1개월 계획은 상세하게, 나머지는 간략하게 작성됩니다. 우선순위는 팀 합의에 따라 언제든지 재정렬 가능합니다.

---

## 📋 목차

- [현재 우선순위 (12월 9일까지)](#현재-우선순위-12월-9일까지)
- [상세 주차별 계획](#상세-주차별-계획)
- [중기 계획 (1-3개월)](#중기-계획-1-3개월)
- [장기 계획 (3개월 이후)](#장기-계획-3개월-이후)
- [계획 재정렬 프로세스](#계획-재정렬-프로세스)

---

## 현재 우선순위 (12월 9일까지)

**기준일**: 2025-11-27
**마감일**: 2025-12-09 (2주)
**상태**: Week 1-3 완료, REFACTORING_TODO.md 완료

### 우선순위 작업 목록

#### 🔴 Priority 1: 턴 플로우 시스템 명확화 및 검증

**담당**: 개발자 1명
**목표**: 매 턴마다 실행되어야 하는 작업들의 명확한 정의 및 함수 일대일 대응

**문제 상황**:

- 매 턴 시작/진행/종료 시 필수 작업(AP 리셋, 스피드 리셋 등)이 누락되거나 중복 호출됨
- 예: `Character::OnTurnStart()`와 `TurnManager::StartNextTurn()`의 `RefreshActionPoints()` 중복
- 실제로 함수가 호출되었는지 확인하기 어려움

**구현 작업**:

1. **턴 플로우 차트 작성** (Day 1-2)
   
   - 턴 시작 시 필수 작업 목록
   - 턴 진행 중 허용 작업
   - 턴 종료 시 필수 작업 목록
   - 라운드 전환 시 작업 목록

2. **함수 일대일 대응** (Day 2-3)
   
   - 플로우 차트의 각 항목과 실제 함수를 1:1 매핑
   - 중복 함수 제거 (OnTurnStart vs RefreshActionPoints)
   - 호출 순서 명확화

3. **디버그 로깅 시스템** (Day 3-4)
   
   - `__PRETTY_FUNCTION__` 매크로로 함수 호출 추적
   - 턴 시작/종료 시 체크리스트 검증
   - 누락된 호출 경고

4. **테스트 및 검증** (Day 4-5)
   
   - 전체 턴 사이클 테스트
   - 로그로 모든 필수 함수 호출 확인
   - 엣지 케이스 테스트 (첫 턴, 마지막 턴, 라운드 전환)

**산출물**:

- 턴 플로우 차트 문서 (Markdown 또는 Mermaid)
- 함수 호출 체크리스트
- 디버그 로그가 포함된 TurnManager 및 Character 코드
- 테스트 레포트

---

#### 🔴 Priority 2: AI 시스템 강화

**담당**: 개발자 1명
**목표**: 4명의 모험가 캐릭터에 대한 robust한 AI 구현

**문제 상황**:

- 현재 AISystem이 기획 당시 플로우차트를 완벽히 대변하지 못함
- 공통 AI 로직과 캐릭터별 차별화된 행동의 경계가 불명확
- 행동 결정 시 bias 조정이 어려움

**구현 작업**:

1. **공통 AI 프레임워크** (Day 1-2)
   
   - 기본 AI 결정 트리 구조
   - 상태 평가 시스템 (HP, AP, 거리, 위협도)
   - 행동 우선순위 계산

2. **캐릭터별 행동 전략** (Day 2-4)
   
   - Fighter: 근접 탱킹, 공격 타이밍 결정
   - Cleric: 힐링 우선순위, 포지셔닝 (향후 구현 대비)
   - Wizard: 스펠 선택, 거리 유지 (향후 구현 대비)
   - Rogue: 은신, 백스탭 타이밍 (향후 구현 대비)

3. **Bias 시스템** (Day 4-5)
   
   - 공격성/방어성 bias
   - 팀워크/개인 플레이 bias
   - 런타임에 조정 가능한 파라미터

4. **테스트 및 밸런싱** (Day 5-6)
   
   - AI vs AI 전투 테스트
   - 다양한 bias 조합 테스트
   - Dragon vs Fighter 밸런스 확인

**산출물**:

- AI 결정 트리 문서
- 캐릭터별 행동 전략 스펙
- Bias 조정 가능한 AISystem 코드
- AI 테스트 시나리오 및 결과

---

#### 🔴 Priority 3: 게임 UI 시스템 구현 및 디버그 UI 개선

**담당**: 개발자 1명
**목표**: 실제 플레이용 게임 UI 구현 및 개발자용 디버그 UI 개선

**문제 상황**:

- 현재 게임 정보 표시 없음 (HP, AP, 턴 순서 등)
- ImGui는 디버깅용으로만 사용 중이며, 실제 플레이에는 부적절 (화면 크기 작음, 가독성 떨어짐)
- 플레이어가 게임 상태를 파악하기 어려움

**구현 작업**:

**Part A: 게임 UI 시스템 (실제 플레이용)** (Day 1-3)

1. **GameUIManager 클래스 생성**
   
   - EventBus에서 게임 이벤트 구독
   - 렌더링 시스템을 통해 화면에 UI 표시 (ImGui 아님!)
   - 플레이어 친화적인 큰 화면, 높은 가독성

2. **캐릭터 정보 UI**
   
   - HP 바 (캐릭터 위 표시)
   - AP 표시
   - 상태 효과 아이콘

3. **전투 정보 UI**
   
   - 턴 순서 표시 (상단 또는 측면)
   - 라운드 번호
   - 액션 로그 (최근 5개 행동)

4. **인터랙티브 UI**
   
   - 마우스 호버 시 캐릭터 상세 정보
   - 스펠 선택 UI
   - 행동 버튼

**Part B: 디버그 UI 개선 (개발자용)** (Day 3-5)

1. **DebugUIManager 클래스 개선**
   
   - ImGui 기반 디버그 패널
   - 런타임 토글 기능 (F-키)
   - 개발자 전용 상세 정보

2. **디버그 패널**
   
   - 그리드 좌표 및 점유 상태
   - AI 결정 트리 시각화
   - 성능 메트릭 (FPS, 메모리 사용량)
   - 이벤트 버스 로그

**산출물**:

- GameUIManager 클래스 (실제 게임용)
- DebugUIManager 클래스 (디버깅용)
- UI 렌더링 시스템
- 단축키 설정 문서

---

#### 🔴 Priority 4: 캐릭터 소유권 모델 재설계

**담당**: 개발자 1명
**목표**: 캐릭터 객체의 명확한 소유권 및 스마트 포인터 적용

**문제 상황**:

- 캐릭터가 팩토리, GameObjectManager, GamePlay 등 여러 곳에서 참조됨
- 소유권이 불명확하여 메모리 누수 위험
- Raw 포인터 사용으로 Dangling Pointer 가능성

**구현 작업**:

1. **소유권 분석** (Day 1)
   
   - 현재 캐릭터 생명주기 추적
   - 소유권 책임 정의 (GameObjectManager가 소유)
   - 참조 관계 정리

2. **스마트 포인터 도입** (Day 2-3)
   
   - GameObjectManager에 `std::unique_ptr` 적용
   - 다른 시스템은 raw pointer 또는 weak_ptr로 참조
   - CharacterFactory는 unique_ptr 반환

3. **CharacterFactory 개선** (Day 3-4)
   
   - `std::unique_ptr<Character>` 반환
   - GameObjectManager에 transfer ownership
   - RAII 원칙 준수

4. **테스트 및 검증** (Day 4-5)
   
   - 캐릭터 생성/삭제 시나리오 테스트
   - 메모리 누수 검사 (Valgrind 또는 VS Memory Profiler)
   - Dangling Pointer 체크

**산출물**:

- 소유권 다이어그램
- 스마트 포인터 적용 코드
- 메모리 안정성 테스트 레포트

---

#### 🔴 Priority 5 & 6: AI 행동 시각화 및 맵 데이터 로딩

**담당**: 개발자 1명
**목표**: AI 행동 pause 시스템 및 JSON 기반 맵 로딩

**Priority 5: AI 행동 시각화** (Day 1-3)

**문제 상황**:

- AI 캐릭터가 행동을 즉시 실행하여 플레이어가 상황 파악 불가
- 어떤 행동이 일어났는지 알기 어려움

**구현 작업**:

1. AI 행동 단계별 pause 시스템
2. 행동 표시 UI (말풍선 또는 텍스트)
3. Pause 시간 조정 가능한 설정
4. 테스트 및 UX 개선

**Priority 6: 맵 데이터 로딩** (Day 3-5)

**문제 상황**:

- 현재 GamePlay.cpp에 하드코딩된 맵 데이터
- 맵 수정 시 재컴파일 필요

**구현 작업**:

1. maps.json 스키마 설계
2. MapDataRegistry 또는 DataRegistry 확장
3. JSON 파싱 및 GridSystem에 적용
4. 여러 맵 테스트

**산출물**:

- AI Pause 시스템 코드
- maps.json 파일
- 맵 로딩 시스템
- 테스트용 맵 2-3개

---

### 역할 분배 (12월 9일까지)

| Priority | 작업 내용          | 담당자   | 예상 시간     |
| -------- | -------------- | ----- | --------- |
| 1        | 턴 플로우 시스템 명확화  | 개발자 A | 5일 (40시간) |
| 2        | AI 시스템 강화      | 개발자 B | 6일 (48시간) |
| 3        | 게임 UI + 디버그 UI | 개발자 C | 5일 (40시간) |
| 4        | 소유권 모델 재설계     | 개발자 D | 5일 (40시간) |
| 5, 6     | AI 시각화 + 맵 로딩  | 개발자 E | 5일 (40시간) |

**총 작업 시간**: 26일 (208시간)
**실제 기간**: 2주 (병렬 작업)

---

## 상세 주차별 계획

### Week 5: 12월 9일까지 우선순위 작업 완료

**목표**: 위 Priority 1-6 완료 및 통합 테스트

**주요 마일스톤**:

- ✅ 턴 플로우 차트 완성 및 함수 일대일 대응
- ✅ AI 시스템 robust 구현
- ✅ 게임 UI 시스템 구현 (실제 플레이용)
- ✅ 디버그 UI 런타임 토글 (개발자용)
- ✅ 캐릭터 스마트 포인터 적용
- ✅ AI pause 시스템
- ✅ JSON 맵 로딩

**통합 테스트** (금요일):

- 전체 시스템 통합 테스트
- 모든 디버그 로그 확인
- 메모리 누수 검사
- 성능 프로파일링

**산출물**:

- Week 5 상세 계획 (week5.md)
- 완성된 시스템 코드
- 테스트 레포트
- 다음 우선순위 논의 자료

---

### Week 6-8: 다음 우선순위 (TBD)

**참고**: 12월 9일 이후 우선순위는 Week 5 완료 후 팀 회의에서 결정

**후보 작업들**:

- Cleric 캐릭터 구현 (힐링 시스템)
- Wizard 캐릭터 구현 (원거리 스펠)
- Rogue 캐릭터 구현 (은신 시스템)
- 추가 Dragon 스펠 (현재 3개 → 6-9개)
- StatusEffectManager 강화 (버프/디버프 시스템)
- 사운드 시스템 기초
- UI 시스템 개선 (메인 메뉴, 옵션)

---

## 중기 계획 (1-3개월)

**참고**: 이 섹션은 architecture.md의 모든 시스템을 포함하되, 간략하게 작성합니다.

### 캐릭터 시스템 확장

**현재 상태**: Dragon, Fighter 구현 완료
**목표**: 모든 캐릭터 클래스 구현

**작업 항목**:

- Cleric 캐릭터 (힐링, 버프 전문)
- Wizard 캐릭터 (원거리 마법 공격)
- Rogue 캐릭터 (은신, 백스탭)
- 캐릭터별 고유 어빌리티 3-5개씩

**예상 기간**: 3-4주

---

### 스펠 시스템 확장

**현재 상태**: 3개 Dragon 스펠 (Fireball, CreateWall, LavaPool)
**목표**: 다양한 레벨 및 타입의 스펠

**작업 항목**:

- 레벨 1-3 스펠 각 3-4개
- 힐링 스펠 (Cleric용)
- 버프/디버프 스펠
- 소환 스펠
- 스펠 업캐스팅 시스템 완성

**예상 기간**: 2-3주

---

### AI 시스템 고도화

**현재 상태**: 기본 Fighter AI
**목표**: 팀 전술 및 고급 AI

**작업 항목**:

- 캐릭터별 AI 전략
- 팀 협동 AI (포커스 파이어, 포지셔닝)
- 난이도 조절 시스템
- AI Director (전체 AI 조율)

**예상 기간**: 3-4주

---

### Status Effect 시스템

**현재 상태**: 기본 구조만 존재
**목표**: 완전한 버프/디버프 시스템

**작업 항목**:

- 상태 효과 타입 정의 (Burn, Poison, Fear, Blessing, Curse 등)
- 스택 시스템 (같은 효과 중첩)
- 지속 시간 관리
- 시각적 피드백

**예상 기간**: 2주

---

### 맵 및 환경 시스템

**현재 상태**: 8x8 기본 그리드
**목표**: 다양한 맵 및 지형 효과

**작업 항목**:

- 여러 맵 디자인 (최소 5개)
- 지형 효과 (용암, 물, 벽, 장애물)
- 높이 시스템 (선택 사항)
- 동적 맵 요소 (함정, 발판)

**예상 기간**: 2-3주

---

## 장기 계획 (3개월 이후)

**참고**: architecture.md의 나머지 시스템들을 간략히 나열

### UI 및 사용자 경험

- 메인 메뉴, 옵션 화면
- 전투 중 UI (스킬 버튼, 정보 패널)
- 튜토리얼 시스템
- 게임 오버/승리 화면

**예상 기간**: 3-4주

---

### 사운드 및 음악

- BGM (전투, 메뉴)
- 효과음 (스펠, 공격, 이동)
- 사운드 관리 시스템

**예상 기간**: 2주

---

### 캠페인 및 진행 시스템

- 여러 전투 스테이지
- 캐릭터 성장 시스템
- 세이브/로드
- 스토리 요소 (선택 사항)

**예상 기간**: 4-5주

---

### 시각 효과 및 애니메이션

- 스펠 이펙트
- 공격 애니메이션
- 파티클 시스템 활용
- 카메라 쉐이크, 화면 효과

**예상 기간**: 2-3주

---

### 최적화 및 폴리싱

- 성능 최적화
- 메모리 사용량 개선
- 버그 수정
- 밸런스 조정

**예상 기간**: 2-3주

---

## 계획 재정렬 프로세스

### 언제 재정렬하는가?

1. **주요 마일스톤 완료 후**: Week 5, Week 8, Week 12 등
2. **새로운 요구사항 발생 시**: 플레이테스트 피드백, 디자인 변경
3. **기술적 문제 발견 시**: 예상보다 오래 걸리는 작업, 의존성 문제

### 재정렬 절차

1. **우선순위 제안**
   
   - 팀원들이 다음에 구현하고 싶은 기능 나열
   - 각 항목의 중요도 및 긴급도 평가

2. **Claude와 기술적 타당성 평가**
   
   - 의존성 분석: 다른 작업과의 선후 관계
   - 위험도 평가: 기술적 난이도, 예상 시간
   - 대안 제시: 더 효율적인 순서가 있는지

3. **팀 합의**
   
   - 평가 결과를 바탕으로 논의
   - 최종 우선순위 결정

4. **문서 업데이트**
   
   - implementation-plan.md 재작성
   - 향후 1개월 계획 상세 작성
   - 나머지는 간략히 유지

5. **주차별 상세 계획 작성**
   
   - week6.md, week7.md 등 작성
   - 구조: Implementation Tasks → Implementation Example → Rigorous Test → Usage Example
   - 5명의 개발자 역할 분담 포함

---

## Architecture.md 전체 시스템 참조

이 구현 계획은 [docs/architecture.md](architecture.md)의 모든 시스템을 기반으로 합니다:

### 핵심 시스템 (완료)

- ✅ Character 계층 구조
- ✅ EventBus (이벤트 시스템)
- ✅ DiceManager (주사위 굴림)
- ✅ GridSystem (8x8 그리드 + A*)
- ✅ TurnManager (턴 관리)
- ✅ CombatSystem (전투 해결)
- ✅ SpellSystem (마법 시스템)
- ✅ AISystem (AI 기초)
- ✅ DataRegistry (JSON 로딩)

### 확장 시스템 (계획됨)

- ⏳ StatusEffectManager (버프/디버프)
- ⏳ CharacterFactory (팩토리 패턴)
- ⏳ MapFactory (맵 생성)
- ⏳ EffectFactory (이펙트 생성)
- ⏳ SaveManager (세이브/로드)
- ⏳ AIDirector (AI 조율)
- ⏳ SoundManager (사운드 관리)

### 컴포넌트 시스템

**GameState Components** (StateComponents):

- ✅ TurnManager, GridSystem, CombatSystem, SpellSystem, AISystem, EventBus, DiceManager, DataRegistry
- ⏳ StatusEffectManager, BattleManager

**GameObject Components** (Character Components):

- ✅ GridPosition, StatsComponent, ActionPoints, SpellSlots, MovementComponent
- ⏳ StatusEffects, AIMemory, DamageCalculator, TargetingSystem

---

## 부록: 개발 원칙

### 모듈 독립성

- 각 시스템은 독립적으로 작동하며 교체 가능
- 느슨한 결합 (EventBus 활용)

### 데이터 기반 설계

- JSON으로 게임 데이터 관리
- 코드 재컴파일 없이 밸런스 조정

### 이벤트 기반 통신

- 시스템 간 직접 의존성 최소화
- EventBus를 통한 통신

### 컴포넌트 기반 아키텍처

- GameState Components (전투 레벨 시스템)
- GameObject Components (개별 엔티티 행동)

### RAII 및 현대 C++

- 스마트 포인터 사용
- 메모리 안전성 우선

---

**최종 업데이트**: 2025-11-27
**다음 업데이트**: Week 5 완료 후 (12월 9일)
**담당**: 프로젝트 리더 및 전체 팀
